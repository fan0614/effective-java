主题：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作。
************************第1条：考虑用静态工厂方法代替构造器(static factory method)**************************************
静态工厂方法：只是返回类的实例的静态方法。
public static Boolean valueOf(boolean b){
	return b ? Boolean.True : Boolean.FALSE;
}

优势：
第一大优势，静态工厂方法有名称。
//当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并慎重地选择名称以便突出它们之间的区别。
第二大优势，不必在每次调用它们的时候都创建一个新对象。
//实例受控制的类(instance-controlled)
编写实例受控制的类的几个原因：
1.实例受控制使得类可以确保它是一个Singleton或者不可实例化的。
2.使得不可变的类可以确保不会存在两个相等的实例。
第三大优势，可以返回原返回类型的任何子类型的对象。这样我们在选择返回对象的类时就有了更大的灵活性。
//可以隐藏实现类会使API变得非常简洁，这项技术适用于基于接口的框架(interface-based framework),在这种框架中，接口为静态工厂方法提供了自然的返回类型。
服务者提供框架(Service Provider Framework)：
是指一个系统: 多个服务提供者实现一个服务，系统为服务提供的客户端提供多个实现，并把他们从多个实现中解耦出来。
三个组件：
服务接口(Service Interface),这是提供者实现的；
提供者注册API(Provider Registration API),这是系统用来注册实现，让客户端访问的.
服务访问API(Service Access API),是客户端用来获取服务实例的。

第四大优势：在创建参数化类型的实例的时候，它们使代码变得更加简洁。
类型推导(type inference)：
public static <K,V> HashMap<K,V> newInstance(){
	return new HashMap<K,V>();
}
Map<String,List<String>> m = HashMap.newInstance();


缺点：
类如果不含公有的或者受保护的构造器，就不能被子类化。
它们与其他的静态方法实际上没什么区别。
**************************第2条：遇到多个构造器参数时要考虑用构建器**************************************************
大量可选参数(类里面的可选域很多)
重叠构造器：
一般选择重叠构造器(telecoping constructor)模式，在这种模式下，你提供第一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个构造器有两个可选参数，依次类推。

javaBeans模式：在这种模式下，调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数以及每个相关的可选参数。
弥补了重叠构造器的不足。
缺点：JavaBeans模式阻止了把类做成不可变的可能。 保证线程安全更加困难。
可以通过freeze方法手工冻结对象
************Builder模式
既能保证重叠构造器模式的安全性，又能保证javaBeans模式的可读性
不直接生成想要的对象，而是让客户端利用所必要的参数调用构造器(或者静态工厂)，得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法，设置每个相关的可选参数。

builder像个构造器一样，可以对其参数强加约束条件。build方法可以检验这些约束条件。

*************************************第3条：用私有构造器或者枚举类型强化Singleton****************************
1.5之前：
//方式1
私有化构造器，导出公有静态成员；
//方式2
公有成员是个静态工厂方法

共有域方法的好处：组成类的成员的声明很清楚地表明了这个类是一个Singleton：共有域是final的，所有该域总是包含相同的对象的引用。

Singleton可序列化：仅仅声明中加上 implements Serializable 是不够的。
为了维护并保证Singleton，必须声明所有的实例域都是瞬时的(transient).并提供一个readResolve方法。

每次反序列化一个序列化的实例时，都会创建一个新的实例；
private Object readResolve(){
	return INSTANCE;
}

jdk1.5提供了枚举类型，可以编写一个只含有单个元素的枚举类型实现Singleton：

枚举类型在功能上与公有域方法相近，但它更加简介，无偿的提供了序列化机制，绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候。

使用单元素的枚举类型已经成为实现Singleton的最佳方法。
***********************************第4条：通过私有构造器强化不可实例化的能力****************
只包含静态方法和静态域的类。
如java.lang.Math 或者 java.util.Arrays的方式

********************************第5条：避免创建不必要的对象**********************************
适配器(adapter) 或者叫做视图(view)
适配器：它把功能委托给一个后备对象(backing object),从而为后备对象提供一个可以替代的接口。

********************************第6条：消除过期的对象引用***********************************


********************************第7条：避免使用终结方法************************************
不必要执行finalizer()方法：1：没有覆写finalizer() 2.虚拟机已经执行过一次finalizer()方法了。

JLS不仅不保证终结方法会被即时的执行，而且根本就不保证它们会被执行。

不应该依赖终结方法来更新重要的持久状态。

System.gc和System.runFinalization两个方法所诱惑，它们确实增加了终结方法被执行的机会，但仍不保证终结方法一定会被执行。
以及System.runFinalizersOnExit 以及Runtime.runFinalizersOnExit.

显示的终止方法通常与try-finally结构结合起来使用，以确保即使终止。在finally子句内部调用显示的终止方法。可以确保即使在使用对象的时候有异常抛出，该终止方法也会执行：
Foo foo = new foo();
try{
...	
}finally{
	foo.terminate();  //Explicit termination method
}

终结方法的用途：
1.当对象的所有者忘记调用前面的段落中建议的显示终止方法时，终结方法可以充当“安全网(safety net)”
2.与对象的本地对等体(native peer)有关。本地对等体是一个本地对象(native Object)，普通对象通过本地方法(native method)委托给一个本地对象。
在本地对等体并不拥有关键资源的前提下，终结方法正是执行这项任务最合适的工具。














